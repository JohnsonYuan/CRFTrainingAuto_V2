namespace CRFTrainingAuto
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Xml;
    using Excel = Microsoft.Office.Interop.Excel;
    using Microsoft.Tts.Offline;
    using Microsoft.Tts.Offline.Utility;
    using System.Text.RegularExpressions;
    using System.Threading.Tasks;
    using System.Collections.ObjectModel;
    using SP = Microsoft.Tts.ServiceProvider;

    public enum GenerateAction
    {
        TestCase,
        TrainingScript
    }

    /// <summary>
    /// Word breaker
    /// </summary>
    public class WordBreaker : IDisposable
    {
        private SP.TtsEngine _engine;

        /// <summary>
        /// Initializes a new instance of the <see cref="WordBreaker"/> class.
        /// </summary>
        /// <param name="language">Language.</param>
        /// <param name="voicePath">Voice font path.</param>
        public WordBreaker(Language lang, string voicePath, string langDataPath)
        {
            Helper.ThrowIfNull(voicePath);

            _engine = new SP.TtsEngine((SP.Language)lang, voicePath, null, langDataPath);
        }

        /// <summary>
        /// Dispose
        /// </summary>
        public void Dispose()
        {
            _engine.Dispose();
        }

        public SP.TtsEngine TtsEngine
        {
            get
            {
                return _engine;
            }
        }

        /// <summary>
        /// Get TtsUtterance
        /// </summary>
        /// <param name="content">input</param>
        /// <param name="sayas">say as tag</param>
        /// <returns>Ttsutterance</returns>
        /// <summary>
        /// Get utterance generated by ESP.
        /// </summary>
        /// <param name="content">Content to be spoken.</param>
        /// <param name="sayas">Sayas used by ESP.</param>
        /// <returns>Utterance enum.</returns>
        public IEnumerable<SP.TtsUtterance> EspUtterances(string content, string sayas = null)
        {
            Helper.ThrowIfNull(_engine);
            Helper.ThrowIfNull(content);

            if (string.IsNullOrEmpty(sayas))
            {
                _engine.SetSpeakText(content);
            }
            else
            {
                _engine.SetSpeakText(content, sayas);
            }

            // reset text processor
            _engine.TextProcessor.Reset();

            while (true)
            {
                SP.TtsUtterance utterance = new SP.TtsUtterance();

                if (!_engine.TextProcessor.Process(utterance))
                {
                    break;
                }

                yield return utterance;
            }
        }

        /// <summary>
        /// Get word break result
        /// </summary>
        /// <example>
        /// input:  父亲在银行界人脉广
        /// output: 父亲 在 银行 界 人脉 广
        /// </example>
        /// <param name="content">input</param>
        /// <returns>word break result</returns>
        public string[] BreakToWords(string sentence)
        {
            Helper.ThrowIfNull(sentence);

            Collection<string> words = new Collection<string>();

            foreach (Microsoft.Tts.ServiceProvider.TtsUtterance utterance in EspUtterances(sentence))
            {
                using (utterance)
                {
                    int num = -1;
                    foreach (SP.TtsWord word in utterance.Words)
                    {
                        if (word.TextOffset != num)
                        {
                            string item = sentence.Substring((int)word.TextOffset, (int)word.TextLength);
                            words.Add(item);
                            num = (int)word.TextOffset;
                        }
                    }
                }
            }
            return words.ToArray();
        }
    }

    #region Extension Methods
    public static class CRFExtensions
    {
        /// <summary>
        /// Check if current string contains single char
        /// </summary> 
        /// <param name="content">input</param>
        /// <param name="charName">char name</param>
        /// <param name="language">language</param>
        /// <param name="voicePath">voice path</param>
        /// <param name="langDataPath">language dat file path</param>
        /// <returns>return -1 if this string doesn't contains single char</returns>
        public static int GetSingleCharIndexOfLine(this string content, string charName, Language language, string voicePath, string langDataPath = null)
        {
            using (WordBreaker wordBreaker = new WordBreaker(language, voicePath, langDataPath))
            {
                return GetSingleCharIndexOfLine(content, charName, wordBreaker);
            }
        }

        /// <summary>
        /// Check if current string contains single char, using generated word break file
        /// </summary>
        /// <param name="content"></param>
        /// <param name="charName"></param>
        /// <param name="wbResult"></param>
        /// <returns></returns>
        public static int GetSingleCharIndexOfLine(this string content, string charName, string[] wbResult)
        {
            int index = content.IndexOf(charName);

            // if contains char, check if contains single char
            if (index > -1)
            {
                int foundCount = 0;
                int tempIndex = -1;

                // find the single char count
                foreach (string word in wbResult)
                {
                    tempIndex += word.Length;

                    if (word == charName)
                    {
                        index = tempIndex;
                        if (++foundCount > 1)
                        {
                            return -1;
                        }
                    }
                }

                // if foundCount == 1, then we return the index, else return -1
                if (foundCount == 1)
                {
                    return index;
                }

                // if foundCount == 1, then we return the index, else return -1
                if (foundCount == 1)
                {
                    return index;
                }
            }
            return -1;
        }

        /// <summary>
        /// Check if current string contains single char, using word breaker
        /// </summary>
        /// <example>
        /// input: 子弹打到尽头弹了回来
        /// output: 6 (子弹 is a word, the result will be second 弹 index)
        /// </example>
        /// <param name="content">input</param>
        /// <param name="charName">char name</param>
        /// <param name="wordBreaker">wordBreaker</param>
        /// <returns>return the single char index, return -1 if this string doesn't contains single char</returns>
        public static int GetSingleCharIndexOfLine(this string content, string charName, WordBreaker wordBreaker)
        {
            int index = content.IndexOf(charName);

            // if contains char, then do word break
            if (index > -1)
            {
                string[] wbResult = null;
                wbResult = wordBreaker.BreakToWords(content);

                int foundCount = 0;
                int tempIndex = -1;

                // find the single char count
                foreach (string word in wbResult)
                {
                    tempIndex += word.Length;

                    if (word == charName)
                    {
                        index = tempIndex;
                        if (++foundCount > 1)
                        {
                            return -1;
                        }
                    }
                }

                // if foundCount == 1, then we return the index, else return -1
                if (foundCount == 1)
                {
                    return index;
                }
            }
            return -1;
        }
    }
    #endregion

    /// <summary>
    /// CRF Helper
    /// </summary>
    public class CRFHelper
    {
        #region Fields
        // the messy part are full-width ! and ?
        private static readonly string[] SentenceSpliters = { "。", "!", "！", ";", "?", "？", "......", "..." };

        // Excel first column for case, second column for corrct pron
        private const int ExcelCaseColIndex = 1;
        private const int ExcelCorrectPronIndex = 2;

        private static int ProcessedFileCount = 0;

        // Use 1000 for N cross folder test
        // Temp folder store filtered corpus data
        private const string TempFolderName = "temp";
        private const string ExcelFileExtension = ".xls";
        private const string TxtFileExtension = ".txt";

        private const string CorpusTxtFileSearchPattern = "*.txt";
        private const string CorpusTxtFileNamePattern = "corpus.{0}.txt";
        private const string CorpusTxtAllFileName = "corpus.all.txt";
        private const string CorpusExcelFileNamePattern = "corpus.{0}.xls";

        public const string TrainingFolderName = "trainingScript";
        public const string NCrossFolderName = "NCross";

        private const string TrainingExcelFileName = "training.xls";
        private const string TestingExcelFileName = "testing.xls";

        private const string TrainingConfigFileName = "training.config";
        private const string TrainingConfigNamespace = "http://schemas.microsoft.com/tts/toolsuite";
        private const string FeatureConfigFileName = "features.config";

        private const string ScriptFileName = "script.xml";
        private const string TrainingFileName = "training.xml";
        private const string TestCaseFileName = "testing.xml";
        private const string TestCaseXmlNamespace = "http://schemas.microsoft.com/tts";
        private const string TestlogFileName = "testlog.txt";
        private const string TestReportFileName = "NCrossTestReport.txt";

        private WordBreaker _wordBreaker;
        private LocalConfig _localConfig;
        #endregion

        /// <summary>
        /// CRFHelper class
        /// </summary>
        /// <param name="config">local config</param>
        public CRFHelper(LocalConfig config)
        {
            _localConfig = config;
            _wordBreaker = new WordBreaker(config.Lang, config.VoicePath, config.LangDataPath);
        }

        /// <summary>
        /// Release resource
        /// </summary>
        ~CRFHelper()
        {
            _wordBreaker.Dispose();
        }

        #region Properties

        /// <summary>
        /// Local config
        /// </summary>
        public LocalConfig LocalConfig
        {
            get
            {
                return _localConfig;
            }
        }

        /// <summary>
        /// ProsodyModelTrainer.exe path, used to train crf model
        /// </summary>
        public string ProsodyModelTrainerPath
        {
            get
            {
                string toolPath = Path.Combine(_localConfig.OfflineToolPath, "ProsodyModelTrainer.exe");

                if (!File.Exists(toolPath))
                {
                    throw new FileNotFoundException(string.Format("ProsodyModelTrainer command file not found: {0}", toolPath));
                }

                return toolPath;
            }
        }

        /// <summary>
        /// FrontendMeasure.exe tool path, used to run test case
        /// </summary>
        public string FrontendMeasurePath
        {
            get
            {
                string toolPath = Path.Combine(_localConfig.OfflineToolPath, "FrontendMeasure.exe");

                if (!File.Exists(toolPath))
                {
                    throw new FileNotFoundException(string.Format("FrontendMeasure command file not found: {0}", toolPath));
                }

                return toolPath;
            }
        }

        /// <summary>
        /// SD.exe tool path
        /// </summary>
        /// <returns></returns>
        public string SdToolPath
        {
            get
            {
                string sdToolPath = Path.Combine(_localConfig.BranchRootPath, @"tools\coretools\sd.exe");

                if (!File.Exists(sdToolPath))
                {
                    throw new FileNotFoundException(string.Format("SD command file not found: {0}", sdToolPath));
                }

                return sdToolPath;
            }
        }
        #endregion

        #region Methods

        /// <summary>
        /// Step 1: Generate txt file contains single training char from inFolder
        /// First generate each file corresponding file to temp folder
        /// and then merge them, random select maxCount data
        /// </summary>
        /// <param name="inputDir">corpus folder</param>
        /// <param name="outputDir">output folder</param>
        /// <param name="wbDir">corpus word break result folder</param>
        public void SelectTargetCharCorpus(string inputDir, string outputDir, string wbDir = null)
        {
            if (!Directory.Exists(inputDir))
            {
                throw new Exception(inputDir + " not exists!");
            }

            string[] inFilePaths = Directory.GetFiles(inputDir, CorpusTxtFileSearchPattern);
            string tempFolder = Path.Combine(outputDir, TempFolderName);

            if (!Directory.Exists(outputDir))
            {
                Directory.CreateDirectory(outputDir);
            }

            if (!Directory.Exists(tempFolder))
            {
                Directory.CreateDirectory(tempFolder);
            }

            Task[] tasks;
            if (inFilePaths.Length <= _localConfig.MaxThreadCount)
            {
                tasks = new Task[inFilePaths.Length];
            }
            else
            {
                tasks = new Task[_localConfig.MaxThreadCount];
            }

            Util.ConsoleOutTextColor("Start filtering");

            for (int i = 0; i < tasks.Length; i++)
            {
                string[] filesToProcess = inFilePaths.Where((input, index) => (index % _localConfig.MaxThreadCount == i)).ToArray();

                // start each task nad show process info when this task complete
                tasks[i] = Task.Factory.StartNew(() =>
                        {
                            SelectTargetChar(filesToProcess, tempFolder, wbDir);
                        }
                    ).ContinueWith((ancient) =>
                    {
                        Console.WriteLine(string.Format("Processed {0} files, total {1} files", ProcessedFileCount, inFilePaths.Length));
                    });
            }

            Task.WaitAll(tasks);

            // clear counter
            ProcessedFileCount = 0;

            // e.g. corpusAllFilePath = "corpus.all.txt"
            string corpusAllFilePath = Path.Combine(outputDir, CorpusTxtAllFileName);
            // merge all files in temp folder
            int mergedFileCount = Util.MergeFiles(Path.Combine(tempFolder, CorpusTxtFileSearchPattern), corpusAllFilePath);

            if (mergedFileCount == 0)
            {
                Util.ConsoleOutTextColor("No data generated, ternimated!");
                return;
            }

            Util.ConsoleOutTextColor(string.Format("All cases saved to {0}.", corpusAllFilePath));

            Util.ConsoleOutTextColor(string.Format("Start random select {0} cases from {1}", _localConfig.MaxCaseCount, corpusAllFilePath));

            string outputExcelFilePath = SelectRandomCorpus(corpusAllFilePath, outputDir);
            if (!string.IsNullOrEmpty(outputExcelFilePath))
            {
                Util.ConsoleOutTextColor(string.Format("Random select {0} cases, saved to {1}", _localConfig.MaxCaseCount, outputExcelFilePath));
            }
            else
            {
                Util.ConsoleOutTextColor(string.Format("{0} doesn't contains {1}  data, can't generate random data.", corpusAllFilePath, _localConfig.MaxCaseCount));
            }
        }

        /// <summary>
        /// Select target char from files
        /// </summary>
        /// <param name="fileProcessed">files corpus</param>
        /// <param name="outputFolder">temp folder</param>
        /// <param name="wbDir">word break result folder</param>
        private void SelectTargetChar(string[] fileProcessed, string outputDir, string wbDir = null)
        {
            bool useWbResult = false;
            if (!string.IsNullOrEmpty(wbDir) &&
                Directory.Exists(wbDir))
            {
                useWbResult = true;
            }

            WordBreaker wordBreaker = null;
            if (!useWbResult)
            {
                wordBreaker = GenWordBreaker();
            }

            foreach (string filePath in fileProcessed)
            {
                string fileName = Path.GetFileName(filePath);

                // if the filtered file already exist, skip this file
                string tempFilePath = Path.Combine(outputDir, fileName);
                if (File.Exists(tempFilePath))
                {
                    ++ProcessedFileCount;
                    Console.WriteLine("File " + fileName + " exist, skipped!");
                    continue;
                }

                HashSet<string> results = new HashSet<string>();

                int foundCount = 0;

                using (StreamReader fileReader = new StreamReader(filePath))
                {
                    // reader for word break result file
                    StreamReader wbReader = null;

                    string wbFilePath = Path.Combine(wbDir, fileName);
                    if (useWbResult &&
                        File.Exists(wbFilePath))
                    {
                        wbReader = new StreamReader(wbFilePath);
                    }
                    else
                    {
                        useWbResult = false;
                    }

                    while (fileReader.Peek() > -1)
                    {
                        #region filter data
                        // remove the empty space, if not, it will get the wrong index when using WordBraker to get the char index
                        string sentence = fileReader.ReadLine().Trim().Replace(" ", "").Replace("\t", "");
                        bool isSentenceMatch = false;

                        // if results donesn't contains the curSentence and curSentence contains only one single char
                        // then add curSentence to results
                        if (useWbResult &&
                            wbReader.Peek() > -1)
                        {
                            string[] wbResult = wbReader.ReadLine().Split(new char[] { ' ' });
                            if (!results.Contains(sentence) &&
                                   sentence.GetSingleCharIndexOfLine(_localConfig.CurrentTrainingChar.CharName, wbResult) > -1)
                            {
                                isSentenceMatch = true;
                            }
                        }
                        else
                        {
                            if (wordBreaker == null)
                            {
                                wordBreaker = GenWordBreaker();
                            }

                            if (!results.Contains(sentence) &&
                                sentence.GetSingleCharIndexOfLine(_localConfig.CurrentTrainingChar.CharName, wordBreaker) > -1)
                            {
                                isSentenceMatch = true;
                            }
                        }

                        if (isSentenceMatch)
                        {
                            results.Add(sentence);

                            ++foundCount;
                            // show searching progress, i is start with 0, so ShowTipCount should minus 1
                            // if ShowTipCount = 5000, when i = 4999, 5000 cases searched
                            if (_localConfig.ShowTipCount > 0 &&
                                foundCount >= _localConfig.ShowTipCount &&
                                foundCount % _localConfig.ShowTipCount == 0)
                            {
                                Console.WriteLine(string.Format("Search {0} in {1}", foundCount, fileName));
                            }
                        }

                        #endregion
                    }

                    // save each file to Temp folder, cause the total file is so large, then merge
                    File.WriteAllLines(tempFilePath, results);

                    ++ProcessedFileCount;

                    Console.WriteLine(string.Format("Found {0} results in file {1}.", foundCount, fileName));

                    if (useWbResult)
                    {
                        wbReader.Dispose();
                    }
                }
            }

            if (wordBreaker != null)
            {
                wordBreaker.Dispose();
            }
        }

        /// <summary>
        /// Generate word breaker using local config
        /// </summary>
        /// <returns>wrod breaker</returns>
        private WordBreaker GenWordBreaker()
        {
            return new WordBreaker(_localConfig.Lang, _localConfig.VoicePath, _localConfig.LangDataPath);
        }

        /// <summary>
        /// Generate maxCount(default 1500) random data from inFilePath
        /// e.g. generate file corpus.1500.txt</summary>
        /// <param name="inFilePath">intput file path</param>
        /// <param name="outputDir">output folder</param>
        /// <returns>generated excel file path, return null if not success</returns>
        public string SelectRandomCorpus(string inFilePath, string outputDir)
        {
            List<string> inputs = new List<string>();
            inputs.AddRange(File.ReadAllLines(inFilePath));

            // check whether can random select
            if (inputs.Count < _localConfig.MaxCaseCount)
            {
                return null;
            }

            HashSet<string> results = new HashSet<string>();
            Random rand = new Random();

            while (results.Count < _localConfig.MaxCaseCount)
            {
                int index = rand.Next(0, inputs.Count);
                string curSentence = inputs[index].Trim();

                if (!results.Contains(curSentence))
                {
                    results.Add(curSentence);
                    // remove this item from input also
                    inputs.Remove(curSentence);
                }
            }

            // save to txt file, it's easyier to view cases
            string randomTxtFilePath = Path.Combine(outputDir, string.Format(CorpusTxtFileNamePattern, _localConfig.MaxCaseCount));
            File.WriteAllLines(randomTxtFilePath, results);

            // generate the excel file
            string outputExcelFilePath = Path.Combine(outputDir, string.Format(CorpusExcelFileNamePattern, _localConfig.MaxCaseCount));
            try
            {
                GenExcelFromTxtFile(randomTxtFilePath, outputExcelFilePath);
            }
            catch (Exception)
            {
                return null;
            }
            return outputExcelFilePath;
        }

        /// <summary>
        /// Generate excel from txt file
        /// Generated Excel file contains 3 column: "case", "correct pron" and "comment"
        /// </summary>
        /// <param name="inFilePath">txt file path</param>
        /// <param name="outputDir">output file path</param>
        public void GenExcelFromTxtFile(string inFilePath, string outputFilePath)
        {
            Console.WriteLine("Generating excel from " + inFilePath);

            // initialize the Excel application Object
            Excel.Application xlApp = new Excel.Application();

            // check whether Excel is installed in your system.
            if (xlApp == null)
            {
                Console.WriteLine("Excel is not properly installed!!");
                return;
            }

            Excel.Workbook xlWorkBook;
            Excel.Worksheet xlWorkSheet;
            object misValue = System.Reflection.Missing.Value;

            // then create new Workbook and WorkSheet
            xlWorkBook = xlApp.Workbooks.Add(misValue);
            xlWorkSheet = (Excel.Worksheet)xlWorkBook.Worksheets.get_Item(1);

            try
            {
                xlWorkSheet.Name = _localConfig.CurrentTrainingChar.CharName;
                xlWorkSheet.Cells[1, 1] = "case";
                xlWorkSheet.Cells[1, 2] = "correct pron";
                xlWorkSheet.Cells[1, 3] = "comment";

                string[] allLines = File.ReadAllLines(inFilePath);

                // Excel start index is 1, the content row start 2
                int rowIndex = 2;

                // fill the sheet
                for (int i = 0; i < allLines.Length; i++)
                {
                    xlWorkSheet.Cells[rowIndex, 1] = allLines[i];

                    // highlight the training character
                    Excel.Range xlRange = (Excel.Range)xlWorkSheet.Cells[rowIndex, 1];
                    int startIndex = allLines[i].GetSingleCharIndexOfLine(_localConfig.CurrentTrainingChar.CharName, _wordBreaker);
                    xlRange.Characters[startIndex + 1, 1].Font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.Red);

                    ++rowIndex;
                }

                xlWorkSheet.Columns.AutoFit();

                // delte the existing excel file
                if (File.Exists(outputFilePath))
                {
                    File.Delete(outputFilePath);
                }

                xlWorkBook.SaveAs(outputFilePath,
                    Excel.XlFileFormat.xlWorkbookNormal,
                    misValue, misValue, misValue, misValue,
                    Excel.XlSaveAsAccessMode.xlExclusive,
                    misValue, misValue, misValue, misValue, misValue);

                Console.WriteLine("Successful generate excel to " + outputFilePath);
            }
            catch (Exception)
            {
                throw;
            }
            finally
            {
                xlWorkBook.Close(true, misValue, misValue);
                xlApp.Quit();

                ReleaseExcelObject(xlWorkSheet);
                ReleaseExcelObject(xlWorkBook);
                ReleaseExcelObject(xlApp);
            }
        }

        /// <summary>
        /// Generate excel from txt files
        /// </summary>
        /// <param name="inFilePaths">txt file paths</param>
        /// <param name="outputDir">output file path</param>
        public void GenExcelFromTxtFiles(string[] inFilePaths, string outputFilePath)
        {
            foreach (string filePath in inFilePaths)
            {
                GenExcelFromTxtFile(filePath, outputFilePath);
            }
        }

        ///<summary>
        /// Step 2: Generate NCrossData from excel
        /// First divide excelFile using N cross folder
        /// each folder contains 900 cases training.xls and 100 cases testing.xls
        /// and then generate training and test script from corresponding excel files
        /// </summary>
        /// <param name="excelFile">excel file path</param>
        /// <param name="outputDir">output folder</outputDir>
        public void GenNCrossData(string excelFile, string outputDir)
        {
            // divide corpus to training and test part, use 
            string trainingExcelFilePath;
            string testExcelFilePath;
            DivideExcelCorpus(excelFile, outputDir, out trainingExcelFilePath, out testExcelFilePath);

            Helper.ThrowIfNull(trainingExcelFilePath);
            Helper.ThrowIfNull(testExcelFilePath);

            // generate scirpt.xml, training.xml, script.xml = training.xml + testing.xml
            GenScript(excelFile, GenerateAction.TrainingScript, outputDir, ScriptFileName);
            GenScript(trainingExcelFilePath, GenerateAction.TrainingScript, outputDir, TrainingFileName);
            // generate testing.xml
            GenScript(testExcelFilePath, GenerateAction.TrainingScript, outputDir, TestCaseFileName);

            // save the n cross test data to NCrossFolder
            string nCrossFolder = Path.Combine(outputDir, NCrossFolderName);
            // divide training excel file corpus to 10 separate testing and training part
            Util.ConsoleOutTextColor("Start N Cross excel : " + trainingExcelFilePath);
            GenNCrossExcel(trainingExcelFilePath, nCrossFolder);
            Util.ConsoleOutTextColor("End N Cross excel : " + trainingExcelFilePath);

            string[] testlogPaths = new string[_localConfig.NFolderCount];

            for (int i = 1; i <= _localConfig.NFolderCount; i++)
            {
                string destDir = Path.Combine(nCrossFolder, i.ToString());
                testlogPaths[i - 1] = Path.Combine(destDir, TestlogFileName);

                // compile and run test in each folder
                try
                {
                    CompileAndTestInFolder(destDir);
                }
                catch (Exception ex)
                {
                    Util.ConsoleOutTextColor(ex.Message, ConsoleColor.Red);
                    return;
                }
            }
            
            // generate report based NCross test log
            string testReportPath = Path.Combine(outputDir, TestReportFileName);
            GenNCrossTestReport(testlogPaths, testReportPath);
            Util.ConsoleOutTextColor("Generate test report " + testReportPath);
        }

        /// <summary>
        /// Divide Excel file to training and test part
        /// </summary>
        /// <param name="excelFilePath">excel file path</param>
        /// <param name="outputDir">output folder</param>
        /// <param name="trainingExcelFilePath">training excel file path</param>
        /// <param name="testExcelFilePath">test excel file path</param>
        private void DivideExcelCorpus(string excelFilePath, string outputDir, out string trainingExcelFilePath, out string testExcelFilePath)
        {
            trainingExcelFilePath = testExcelFilePath = null;

            // initialize the Excel application Object
            Excel.Application xlApp = new Excel.Application();

            // check whether Excel is installed in your system.
            if (xlApp == null)
            {
                Console.WriteLine("Excel is not properly installed!!");
                return;
            }

            Excel.Workbook xlWorkBook = xlApp.Workbooks.Open(excelFilePath, 0, false, 5, "", "", false, Excel.XlPlatform.xlWindows, "",
                        true, false, 0, true, false, false);
            object misValue = System.Reflection.Missing.Value;

            Excel.Worksheet xlWorkSheet = (Excel.Worksheet)xlWorkBook.Worksheets.get_Item(1);

            Dictionary<string, string> caseAndProns = GetCaseAndPronsFromExcel(xlWorkSheet.UsedRange, false);

            if (caseAndProns != null && caseAndProns.Count() > _localConfig.NCrossCaseCount)
            {
                // generate training and test script
                string trainingFolder = Path.Combine(outputDir, TrainingFolderName);

                if (!Directory.Exists(trainingFolder))
                {
                    Directory.CreateDirectory(trainingFolder);
                }

                // generate excel for training, e.g. corpusCountFilePath = "corpus.1000.xls"
                trainingExcelFilePath = Path.Combine(outputDir, string.Format(CorpusExcelFileNamePattern, _localConfig.NCrossCaseCount));
                var trainingCaseAndProns = caseAndProns.Where((input, index) => (index >= 0 && index < _localConfig.NCrossCaseCount));
                
                Util.ConsoleOutTextColor(string.Format("Split {0} case from {1}, saved to {2}.", _localConfig.NCrossCaseCount, excelFilePath, trainingExcelFilePath));
                GenExcelFromCaseAndProns(trainingCaseAndProns, trainingExcelFilePath);

                // generate excel for test cases, e.g. corpusCountFilePath = "corpus.500.xls"
                int testCount = _localConfig.MaxCaseCount - _localConfig.NCrossCaseCount;
                testExcelFilePath = Path.Combine(outputDir, string.Format(CorpusExcelFileNamePattern, testCount));
                var testCaseAndProns = caseAndProns.Where((input, index) => (index >= _localConfig.NCrossCaseCount));
                
                Util.ConsoleOutTextColor(string.Format("Split {0} case from {1}, saved to {2}.", testCount, excelFilePath, testExcelFilePath));
                GenExcelFromCaseAndProns(testCaseAndProns, testExcelFilePath);
            }
            else
            {
                Util.ConsoleOutTextColor(string.Format("The excel file doesn't content min {0} cases for training.", _localConfig.NCrossCaseCount), ConsoleColor.Red);
            }

            if (xlWorkBook != null)
            {
                xlWorkBook.Close(true, misValue, misValue);
            }
            if (xlApp != null)
            {
                xlApp.Quit();
            }

            ReleaseExcelObject(xlWorkSheet);
            ReleaseExcelObject(xlWorkBook);
            ReleaseExcelObject(xlApp);
        }

        /*
        /// <summary>
        /// Divide the corpus file and genreate corresponding exce file
        /// </summary>
        /// <param name="randomFilePath"></param>
        /// <param name="outputDir"></param>
        private void DivideCorpusAndGenerateExcel(string randomFilePath, string outputDir)
        {
            string[] results = File.ReadLines(randomFilePath).ToArray();

            if (results != null && results.Length > 0)
            {
                // e.g. currently we use total 1500 case, divide 1000 for training, 500 for testing
                if (_localConfig.MaxCaseCount > _localConfig.NCrossCaseCount)
                {
                    // generate training and test script
                    string outputResultDir = Path.Combine(outputDir, FinalResultFolder);
                    if (!Directory.Exists(outputResultDir))
                    {
                        Directory.CreateDirectory(outputResultDir);
                    }

                    string trainingFolder = Path.Combine(outputResultDir, TrainingFolderName);

                    if (!Directory.Exists(trainingFolder))
                    {
                        Directory.CreateDirectory(trainingFolder);
                    }

                    // e.g. corpusNCaseFilePath = "corpus.1000.txt"
                    string corpusNCaseTxtFile = Path.Combine(outputResultDir, string.Format(CorpusFileNamePattern, _localConfig.NCrossCaseCount));
                    File.WriteAllLines(corpusNCaseTxtFile, results.Where((input, index) => (index >= 0 && index < _localConfig.NCrossCaseCount)));
                    Util.ConsoleOutTextColor(string.Format("Split {0} case from {1}, saved to {2}.", _localConfig.NCrossCaseCount, Path.GetFileName(randomFilePath), corpusNCaseTxtFile));
                    // generate excel
                    string nCaseExcelFilePath = Util.ChangeFileExtension(corpusNCaseTxtFile, ExcelFileExtension);
                    GenerateExcelFromTxtFile(corpusNCaseTxtFile, nCaseExcelFilePath);

                    // e.g. corpusCountFilePath = "corpus.500.txt"
                    int leftCount = _localConfig.MaxCaseCount - _localConfig.NCrossCaseCount;
                    string corpusLeftTxtFile = Path.Combine(outputResultDir, string.Format(CorpusFileNamePattern, leftCount));
                    File.WriteAllLines(corpusLeftTxtFile, results.Where((input, index) => (index >= _localConfig.NCrossCaseCount)));
                    Util.ConsoleOutTextColor(string.Format("Split {0} case from {1}, saved to {2}.", leftCount, Path.GetFileName(randomFilePath), corpusLeftTxtFile));
                    // generate excel
                    string leftExcelFilePath = Util.ChangeFileExtension(corpusLeftTxtFile, ExcelFileExtension);
                    GenerateExcelFromTxtFile(corpusLeftTxtFile, leftExcelFilePath);
                }
            }
        }
*/

        /// <summary>
        /// Compile and run test in folder
        /// </summary>
        /// <param name="destDir">folder</param>
        public void CompileAndTestInFolder(string destDir)
        {
            // generate ing.config and feature.config for crf training
            GenCRFTrainingConfig(destDir);

            Util.ConsoleOutTextColor("Training crf model in " + destDir);
            string message = "";

            if (TrainingCRFModel(Path.Combine(destDir, TrainingConfigFileName),
                Path.Combine(destDir, "traininglog", "log.xml"),
                ref message))
            {
                Util.ConsoleOutTextColor(message);
            }
            else
            {
                throw new Exception(message);
            }

            Util.ConsoleOutTextColor("Compiling language data " + destDir);
            string generatedCrf = Path.Combine(destDir, _localConfig.CurrentTrainingChar.OutputCRFName);

            string generatedDataFile;
            // compile lang  data file
            if (CompileLangData(generatedCrf, _localConfig.CRFModelDir, destDir, out generatedDataFile))
            {
                Util.ConsoleOutTextColor("Successful compile " + generatedDataFile);
            }
            else
            {
                Util.ConsoleOutTextColor("Compile failed in" + destDir, ConsoleColor.Red);
                return;
            }

            string testcaseFile = Path.Combine(destDir, TestCaseFileName);
            if(File.Exists(testcaseFile))
            {
                Util.ConsoleOutTextColor("Running test " + testcaseFile);
                if (TestCRFModel(generatedDataFile,
                    testcaseFile,
                    Path.Combine(destDir, TestlogFileName),
                    ref message))
                {
                    Util.ConsoleOutTextColor(message);
                }
                else
                {
                    Util.ConsoleOutTextColor(message, ConsoleColor.Red);
                    return;
                }
            }
        }

        /// <summary>
        /// Divide 1000 corpus to 10 separate testing and training part
        /// </summary>
        /// <param name="excelFile">excel file path</param>
        /// <param name="outputDir">output folder</param>
        public void GenNCrossExcel(string excelFile, string outputDir)
        {
            // initialize the Excel application Object
            Excel.Application xlApp = new Excel.Application();

            // check whether Excel is installed in your system.
            if (xlApp == null)
            {
                Console.WriteLine("Excel is not properly installed!!");
                return;
            }

            Excel.Workbook xlWorkBook = xlApp.Workbooks.Open(excelFile, 0, false, 5, "", "", false, Excel.XlPlatform.xlWindows, "",
                        true, false, 0, true, false, false);
            object misValue = System.Reflection.Missing.Value;

            Excel.Worksheet xlWorkSheet = (Excel.Worksheet)xlWorkBook.Worksheets.get_Item(1);

            Dictionary<string, string> caseAndProns = GetCaseAndPronsFromExcel(xlWorkSheet.UsedRange);

            int count = 100;

            // Generate 10 cross folder
            for (int i = 0; i < _localConfig.NFolderCount; i++)
            {
                var testingcaseAndProns = caseAndProns.Where((kvPair, index) =>
                    index >= i * count && index < (i + 1) * count);
                var trainingcaseAndProns = caseAndProns.Where((kvPair, index) =>
                    (index >= 0 && index < i * count) || (index >= (i + 1) * count && index < 1000));

                string dirPath = Path.Combine(outputDir, (i + 1).ToString());
                string trainingFolder = Path.Combine(dirPath, TrainingFolderName);

                if (!Directory.Exists(dirPath))
                {
                    Directory.CreateDirectory(dirPath);
                }

                if (!Directory.Exists(trainingFolder))
                {
                    Directory.CreateDirectory(trainingFolder);
                }

                Console.WriteLine("Generating test and training script to " + dirPath);

                GenTestCase(testingcaseAndProns.ToDictionary(p => p.Key, p => p.Value), Path.Combine(dirPath, TestCaseFileName));
                GenTrainingScript(trainingcaseAndProns.ToDictionary(p => p.Key, p => p.Value), Path.Combine(trainingFolder, TrainingFileName));
            }

            if (xlWorkBook != null)
            {
                xlWorkBook.Close(true, misValue, misValue);
            }
            if (xlApp != null)
            {
                xlApp.Quit();
            }

            ReleaseExcelObject(xlWorkSheet);
            ReleaseExcelObject(xlWorkBook);
            ReleaseExcelObject(xlApp);
        }

        /// <summary>
        /// Each Dictionary item contains the case and the pron
        /// </summary>
        /// <param name="usedRange">Excel used range</param>
        /// <param name="useNavtivePhone">if true, the return value's pron is native pron, else use pinyin</param>
        /// <returns>Dictionary contains case and native pron</returns>
        private Dictionary<string, string> GetCaseAndPronsFromExcel(Excel.Range usedRange, bool useNavtivePhone = true)
        {
            Dictionary<string, string> caseAndProns = new Dictionary<string, string>();

            for (int rCnt = 2; rCnt <= usedRange.Rows.Count; rCnt++)
            {
                // first column for case, second column for corrct pron
                string caseVal = Convert.ToString((usedRange.Cells[rCnt, ExcelCaseColIndex] as Excel.Range).Value2);
                string pinYinPron = Convert.ToString((usedRange.Cells[rCnt, ExcelCorrectPronIndex] as Excel.Range).Value2);

                if (!caseAndProns.ContainsKey(caseVal))
                {
                    // check the pron is in config file
                    if ((_localConfig.CurrentTrainingChar.Prons.ContainsKey(pinYinPron) &&
                        !string.IsNullOrEmpty(_localConfig.CurrentTrainingChar.Prons[pinYinPron])))
                    {
                        // if don't use native phone, we add the pinyin pron to result
                        if (!useNavtivePhone)
                        {
                            caseAndProns.Add(caseVal, pinYinPron);
                        }
                        else
                        {
                            caseAndProns.Add(caseVal, _localConfig.CurrentTrainingChar.Prons[pinYinPron]);
                        }
                    }
                    else
                    {
                        string errorMsg = string.Format("Excel file in row {0} has the wrong pron \"{1}\"! It should like ", rCnt, pinYinPron);
                        foreach (string val in _localConfig.CurrentTrainingChar.Prons.Keys)
                        {
                            errorMsg += val + " ";
                        }
                        errorMsg += ".";
                        throw new FormatException(errorMsg);
                    }
                }
            }
            return caseAndProns;
        }

        /// <summary>
        /// Generate Excel From caseAndProns
        /// </summary>
        /// </summary>
        /// <param name="caseAndProns">case and pron</param>
        /// <param name="outputFilePath">output file path</param>
        public void GenExcelFromCaseAndProns(IEnumerable<KeyValuePair<string, string>> caseAndProns, string outputFilePath)
        {
            if (File.Exists(outputFilePath))
            {
                File.Delete(outputFilePath);
            }

            // initialize the Excel application Object
            Excel.Application xlApp = new Excel.Application();

            // check whether Excel is installed
            if (xlApp == null)
            {
                Console.WriteLine("Excel is not properly installed!!");
                return;
            }

            Excel.Workbook xlWorkBook;
            Excel.Worksheet xlWorkSheet;
            object misValue = System.Reflection.Missing.Value;
            xlWorkBook = xlApp.Workbooks.Add(misValue);
            xlWorkSheet = (Excel.Worksheet)xlWorkBook.Worksheets.get_Item(1);

            try
            {
                xlWorkSheet.Name = _localConfig.CurrentTrainingChar.CharName;
                xlWorkSheet.Cells[1, 1] = "case";
                xlWorkSheet.Cells[1, 2] = "correct pron";
                xlWorkSheet.Cells[1, 3] = "comment";

                int rowIndex = 2;

                foreach (KeyValuePair<string, string> item in caseAndProns)
                {
                    xlWorkSheet.Cells[rowIndex, 1] = item.Key;
                    xlWorkSheet.Cells[rowIndex, 2] = item.Value;

                    Excel.Range xlRange = (Excel.Range)xlWorkSheet.Cells[rowIndex, 1];
                    int startIndex = item.Key.IndexOf(_localConfig.CurrentTrainingChar.CharName);
                    if (startIndex > -1)
                    {
                        xlRange.Characters[startIndex + 1, 1].Font.Color = System.Drawing.ColorTranslator.ToOle(System.Drawing.Color.Red);
                    }
                    ++rowIndex;
                }

                xlWorkSheet.Columns.AutoFit();

                xlWorkBook.SaveAs(outputFilePath,
                    Excel.XlFileFormat.xlWorkbookNormal,
                    misValue, misValue, misValue, misValue,
                    Excel.XlSaveAsAccessMode.xlExclusive,
                    misValue, misValue, misValue, misValue, misValue);
            }
            catch (Exception)
            {
            }
            finally
            {
                xlWorkBook.Close(true, misValue, misValue);
                xlApp.Quit();

                ReleaseExcelObject(xlWorkSheet);
                ReleaseExcelObject(xlWorkBook);
                ReleaseExcelObject(xlApp);
            }
        }

        /// <summary>
        /// Generate training script or test case
        /// </summary>
        /// <param name="excelFilePath">excel file path</param>
        /// <param name="action">generate training or test script</param>
        /// <param name="outputDir">output folder</param>
        /// <param name="outputFileName">if not supply, TrainingFileName(training.xml) for training script, TestCaseFileName(testing.xml) for test case</param>
        public void GenScript(string excelFilePath, GenerateAction action, string outputDir, string outputFileName = null)
        {
            // initialize the Excel application Object
            Excel.Application xlApp = new Excel.Application();

            // check whether Excel is installed in your system.
            if (xlApp == null)
            {
                Console.WriteLine("Excel is not properly installed!!");
                return;
            }

            Excel.Workbook xlWorkBook = xlApp.Workbooks.Open(excelFilePath, 0, false, 5, "", "", false, Excel.XlPlatform.xlWindows, "",
                        true, false, 0, true, false, false);
            object misValue = System.Reflection.Missing.Value;

            Excel.Worksheet xlWorkSheet = (Excel.Worksheet)xlWorkBook.Worksheets.get_Item(1);
            Excel.Range range = xlWorkSheet.UsedRange;

            try
            {
                if (VerifyExcelSheet(xlWorkSheet))
                {
                    // load cases and prons
                    Dictionary<string, string> caseAndProns = GetCaseAndPronsFromExcel(range);
                    string outputFilePath;
                    switch (action)
                    {
                        case GenerateAction.TestCase:
                            // Generate FM Test Cases, if not supply file name, using TestCaseFileName as default name
                            Util.ConsoleOutTextColor("Generate test cases for " + excelFilePath);
                            outputFilePath = Path.Combine(outputDir, outputFileName ?? TestCaseFileName);

                            GenTestCase(caseAndProns, outputFilePath);
                            break;
                        case GenerateAction.TrainingScript:
                            // Generate training script, if not supply file name, using TrainingFileName as default name
                            Util.ConsoleOutTextColor("Generating training script for " + excelFilePath);
                            outputFilePath = Path.Combine(outputDir, outputFileName ?? TrainingFileName);

                            // currently, the 3rd para is always null, if specified, output file's start index continue with existing script file
                            GenTrainingScript(caseAndProns, outputFilePath, null);
                            break;
                        default:
                            break;
                    }
                }
                else
                {
                    Console.WriteLine("The excel doesn't contains enough data!");
                    return;
                }
            }
            catch(Exception ex)
            {
                Util.ConsoleOutTextColor(ex.Message, ConsoleColor.Red);
            }
            finally
            {
                if (xlWorkBook != null)
                {
                    xlWorkBook.Close(true, misValue, misValue);
                }
                if (xlApp != null)
                {
                    xlApp.Quit();
                }

                ReleaseExcelObject(xlWorkSheet);
                ReleaseExcelObject(xlWorkBook);
                ReleaseExcelObject(xlApp);
            }
        }

        /// <summary>
        /// Generate test case file
        /// </summary>
        /// <example>
        /// <cases lang="zh-CN" component="Pronunciation" xmlns="http://schemas.microsoft.com/tts">
        ///   <case priority="P1" category="polyphone" pron_polyword="弹" index="1">
        ///      <input>”怎么变形都能弹回原状此外，此款眼镜还采用了柔性镜腿，精选高弹性塑胶钛制造，镜腿360度旋转不折断无变形。</input>
        ///      <output>
        ///           <part>t a_l nn_h</part>
        ///      </output>
        ///   </case>
        ///   <case priority="P1" category="polyphone" pron_polyword="弹">
        ///        <input>寂静的深山里，顿时炮声隆隆，飞弹呼啸，硝烟弥漫。</input>
        ///        <output>
        ///             <part>d a_h nn_l</part>
        ///        </output>
        ///   </case>
        /// </cases>
        /// </example>
        /// <param name="caseAndProns">dictionary contains case and pron</param>
        /// <param name="outputFilePath">output xml file path</param>
        private void GenTestCase(Dictionary<string, string> caseAndProns, string outputFilePath)
        {
            XmlWriterSettings settings = new XmlWriterSettings
            {
                Indent = true,
                IndentChars = "     ",
                Encoding = System.Text.Encoding.Unicode,
            };

            using (XmlWriter xtw = XmlTextWriter.Create(outputFilePath, settings))
            {
                xtw.WriteStartElement("cases", TestCaseXmlNamespace);
                xtw.WriteAttributeString("lang", Localor.LanguageToString(_localConfig.Lang));
                xtw.WriteAttributeString("component", "Pronunciation");

                string charName = _localConfig.CurrentTrainingChar.CharName;

                foreach (string testCase in caseAndProns.Keys)
                {
                    xtw.WriteStartElement("case");
                    xtw.WriteAttributeString("priority", "P1");
                    xtw.WriteAttributeString("category", "polyphone");
                    xtw.WriteAttributeString("pron_polyword", _localConfig.CurrentTrainingChar.CharName);

                    // the content might have more than one target char
                    // e.g. index start from 1 <case priority='P1' category='polyphone' pron_polyword='还' index='2'>
                    int tempIndex = testCase.IndexOf(charName);
                    // make sure this case has more than one char
                    if (tempIndex > -1 && testCase.IndexOf(charName, tempIndex + 1) > -1)
                    {
                        int charIndex = testCase.GetSingleCharIndexOfLine(charName, _wordBreaker);

                        // if cannot find the single char index, skip this case
                        if (charIndex == -1)
                        {
                            continue;
                        }

                        int charCount = 0;

                        while (tempIndex != charIndex)
                        {
                            ++charCount;
                            tempIndex = testCase.IndexOf(charName, tempIndex + 1);
                        }

                        xtw.WriteAttributeString("index", charCount.ToString());
                    }

                    xtw.WriteStartElement("input");
                    xtw.WriteString(testCase);
                    xtw.WriteEndElement();

                    xtw.WriteStartElement("output");
                    xtw.WriteElementString("part", caseAndProns[testCase]);
                    xtw.WriteEndElement();

                    xtw.WriteEndElement();
                }
                xtw.WriteEndElement();
                xtw.WriteEndDocument();
            }

            // genereate a txt file with same name for clear look
            File.WriteAllLines(Util.ChangeFileExtension(outputFilePath, TxtFileExtension), caseAndProns.Keys);

            Console.WriteLine("Generate test case " + outputFilePath);
        }

        /// <summary>
        /// Generate training scirpt, if specify the existing script, output file's start index continue with existing script file
        /// </summary>
        /// <example>
        /// <script language="zh-CN" xmlns="http://schemas.microsoft.com/tts">
        ///   <si id="0000000861">
        ///     <text>莹莹水润的Q弹啫喱质地，脂玉一般清润透亮的色泽，极为清淡的植物清香，很”美味“的样子。</text>
        ///     <sent>
        ///       <text>莹 莹 水 润 的 Q 弹 啫 喱 质地 , 脂 玉 一般 清润 透亮 的 色泽 , 极为 清淡 的 植物 清香 , 很 " 美味 " 的 样子 。</text>
        ///       <words>
        ///         <w v="莹" p="yi el_l ng_h" type="normal" />
        ///         ......
        ///       </words>
        ///     </sent>
        ///   </si>
        ///   <si id="0000000862">
        ///   ......
        ///   </si>
        /// </script>
        /// </example>
        /// <param name="caseAndProns">dictionary contains case and pron</param>
        /// <param name="outputFilePath">output xml file path</param>
        /// <param name="existingScriptPath">existing script file path</param>
        private void GenTrainingScript(Dictionary<string, string> caseAndProns, string outputFilePath, string existingScriptPath = "")
        {
            int startId = 1;
            // if existing script file exist, the generate item's id attribute should be continuted, else start with 1
            if (!string.IsNullOrEmpty(existingScriptPath) && File.Exists(existingScriptPath))
            {
                XmlDocument doc = new XmlDocument();
                doc.Load(existingScriptPath);
                XmlNodeList list = doc.DocumentElement.ChildNodes;
                if (list != null && list.Count > 0)
                {
                    startId = Convert.ToInt32(list.Item(list.Count - 1).Attributes["id"].Value) + 1;
                }
            }

            XmlScriptFile result = new XmlScriptFile(_localConfig.Lang);

            foreach (string testCase in caseAndProns.Keys)
            {
                ScriptItem item = GenerateScriptItem(testCase);

                ScriptWord charWord = item.AllWords.FirstOrDefault(p => p.Grapheme.Equals(_localConfig.CurrentTrainingChar.CharName, StringComparison.InvariantCultureIgnoreCase));

                if (charWord != null)
                {
                    charWord.Pronunciation = caseAndProns[testCase];

                    item.Id = string.Format("{0:D10}", startId);

                    // make sure each word contains pron, if not, use the default pron
                    foreach (ScriptWord word in item.AllWords)
                    {
                        // force to provide pronunciation when training, it's necessary for training crf model
                        if (string.IsNullOrEmpty(word.Pronunciation))
                        {
                            word.Pronunciation = _localConfig.DefaultWordPron;
                            word.WordType = WordType.Normal;
                        }

                        /* if PronSource == PolyphonyCRFModel or PolyphonyRNNModel, it will cause error below:
                            Data format error in the line 1028 : The 'pronSource' attribute is invalid - The value 'polyphonyRNN
                            Model' is invalid according to its datatype 'http://schemas.microsoft.com/tts:pronSourceType' - The
                            Enumeration constraint failed.
                         */
                        if (word.PronSource == TtsPronSource.PolyphonyCRFModel ||
                            word.PronSource == TtsPronSource.PolyphonyRNNModel)
                        {
                            word.PronSource = TtsPronSource.None;
                        }
                    }

                    result.Items.Add(item);
                    ++startId;
                }
            }

            result.Save(outputFilePath, System.Text.Encoding.Unicode);

            // genereate a txt file with same name for clear look
            File.WriteAllLines(Util.ChangeFileExtension(outputFilePath, TxtFileExtension),
                               caseAndProns.Keys);

            Console.WriteLine("Generate training script " + outputFilePath);
        }

        /// <summary>
        /// Generate report from all testResults
        /// </summary>
        /// <example>
        /// frontmeasure test report is like below, Match Ratio          = 92.00 it the redio result line
        /// 
        /// POLYPHONE: 弹
        /// INPUT: (P1)
        /// 我曾经三次上战场，我上去是要带着光荣弹，最后一颗子弹留给自己的，这绝对的牺牲，这点是西方军队比不了的。
        /// EXPECTED: 
        /// d a_h nn_l / 
        /// RESULT: 
        /// t a_l nn_h / 
        /// 
        /// Test result of component: Pronunciation
        /// Test language: ZhCN
        /// Total Speak                = 100
        /// Total Pass                 = 92
        /// Total Fail                 = 8
        /// Total Error          = 0
        /// Match Ratio          = 92.00
        /// </example>
        /// <param name="testResultFiles">test result files</param>
        /// <param name="outputFilePath">output file path</param>
        public void GenNCrossTestReport(string[] testResultFiles, string outputFilePath)
        {
            if(testResultFiles == null ||
                testResultFiles.Length <= 0)
            {
                return;
            }

            List<string> reportResults = new List<string>();
            reportResults.Add("Item\tTraining\tTesting\tAccuracy\tDiff");
            double[] radios = new double[testResultFiles.Length];
            
            for (int i = 0; i < testResultFiles.Length; i++)
            {
                using (StreamReader reader = new StreamReader(testResultFiles[i]))
                {
                    while (reader.Peek() > -1)
                    {
                        string line = reader.ReadLine();
                        // find the the radio result line
                        Match match = Regex.Match(line, @"(?:Match Ratio *= )(\d+\.\d+)");
                        if (match.Success)
                        {
                            try
                            {
                                radios[i] = Double.Parse(match.Groups[1].Value);
                            }
                            catch
                            {
                                throw new Exception("Report format is not correct!");
                            }
                            break;
                        }
                    }
                }
            }

            // comput the average radio
            double aveRadio = radios.Average();

            // generate report content
            for (int i = 1; i <= radios.Length; i++)
            {
                double diff = radios[i - 1] - aveRadio;
                int trainCount = Convert.ToInt32(_localConfig.NCrossCaseCount * 0.9);
                int testCount = _localConfig.NCrossCaseCount - trainCount;
                reportResults.Add(string.Format("Set{0}\t{1}\t{2}\t{3}\t{4:00.00}", i,trainCount, testCount, radios[i - 1], diff));
            }

            reportResults.Add("");
            reportResults.Add(string.Format("Average radio: {0:00.00}", aveRadio));

            File.WriteAllLines(outputFilePath, reportResults);
        }

        /// <summary>
        /// Using ProsodyModelTrainer.exe to train crf
        /// </summary>
        /// <param name="configPath">training config file path</param>
        /// <param name="logPath">training xml file log</param>
        /// <param name="message">result message</param>
        /// <returns>success or not</returns>
        public bool TrainingCRFModel(string configPath, string logPath, ref string message)
        {
            string sdMsg = string.Empty;

            try
            {
                Int32 sdExitCode = CommandLine.RunCommandWithOutputAndError(ProsodyModelTrainerPath,
                        string.Format("-config {0} -log {1}", configPath, logPath), null, ref sdMsg);

                if (sdExitCode == 0 && !string.IsNullOrEmpty(sdMsg))
                {
                    message = string.Format("Successfully training CRF Model: {0}", logPath);

                    // copy and renaming the trained file
                    XmlDocument doc = new XmlDocument();
                    doc.Load(configPath);
                    // currently the namespace is http://schemas.microsoft.com/tts/toolsuite
                    XmlNamespaceManager nsmgr = new XmlNamespaceManager(doc.NameTable);
                    nsmgr.AddNamespace("ns", TrainingConfigNamespace);
                    XmlNode node = doc.SelectSingleNode("//ns:input[@name='$env.OutputDir']", nsmgr);

                    if (node != null && Directory.Exists(node.InnerText))
                    {
                        string outputDir = node.InnerText;

                        // rename the file *.td to *.crf
                        string tempTDfile = Directory.GetFiles(outputDir, "*.TD").FirstOrDefault();
                        if (tempTDfile != null)
                        {
                            File.Copy(tempTDfile, Path.Combine(outputDir, _localConfig.CurrentTrainingChar.OutputCRFName), true);
                            Console.WriteLine("generate file: " + Path.Combine(outputDir, _localConfig.CurrentTrainingChar.OutputCRFName));
                            return true;
                        }
                    }
                }
                else
                {
                    message = string.Format("Failed training CRF Model : {0}", sdMsg);
                    return false;
                }

                if (sdExitCode != 0)
                {
                    return false;
                }
            }
            catch (Exception e)
            {
                message = string.Format("--{0}. Failed to training : {1}", e.Message, logPath);
            }
            return false;
        }

        /// <summary>
        /// Generate corresponding training.config and feature.config outputDir
        /// </summary>
        /// <param name="configTemplateDir">dir contains training.config and feature.config template</param>
        public void GenCRFTrainingConfig(string outputDir)
        {
            XmlDocument doc = new XmlDocument();
            doc.LoadXml(_localConfig.TrainingConfigTemplate);

            foreach (XmlNode node in doc.DocumentElement.GetElementsByTagName("include").Item(0))
            {
                string attribute = node.Attributes["name"].Value;
                switch (attribute)
                {
                    case "$feature.TargetWord":
                        node.InnerXml = _localConfig.CurrentTrainingChar.CharName;
                        break;
                    case "$env.Language":
                        node.InnerXml = Localor.LanguageToString(_localConfig.Lang);
                        break;
                    case "$env.LexiconSchemaFile":
                    case "$env.PhoneSetFile":
                        node.InnerXml = node.InnerXml.Replace("#branch_root#", _localConfig.BranchRootPath).Replace("#lang#", Localor.LanguageToString(_localConfig.Lang));
                        break;
                    case "$env.LinguisticFeatureListFile":
                        node.InnerXml = Path.Combine(outputDir, FeatureConfigFileName);
                        break;
                    case "$env.OutputDir":
                        node.InnerXml = outputDir;
                        break;
                    case "$env.Script":
                        node.InnerXml = Path.Combine(outputDir, TrainingFolderName);
                        break;
                    default:
                        break;
                }
            }

            doc.Save(Path.Combine(outputDir, TrainingConfigFileName));

            // copy the feature.config
            doc.LoadXml(_localConfig.FeaturesConfigTemplate);
            doc.Save(Path.Combine(outputDir, FeatureConfigFileName));
        }

        /// <summary>
        /// Compile data file
        /// </summary>
        /// <param name="crfFilePath">trained crf file</param>
        /// <param name="crfModelDir">crf model folder</param>
        /// <param name="outputDir">data file output folder</param>
        /// <returns>generated dat fiel path</returns>
        public bool CompileLangData(string crfFilePath, string crfModelDir, string outputDir, out string generatedFilePath)
        {
            string srcDataFilePattern = Path.Combine(_localConfig.OfflineToolPath, "LocaleHandler", "MSTTSLoc{0}.dat");
            string srcDataFilePath = string.Format(srcDataFilePattern, _localConfig.Lang);

            // copy the original dat file to outputDir
            generatedFilePath = Path.Combine(outputDir, Path.GetFileName(srcDataFilePath));

            // copy dat file to current output folder
            File.Copy(srcDataFilePath, generatedFilePath, true);

            // copy trained crf file to crfModel folder
            File.Copy(crfFilePath, Path.Combine(crfModelDir, Path.GetFileName(crfFilePath)), true);

            // Edit the CRFLocalizedMapping.txt file
            string crfModelNameMappingFile = Path.Combine(new DirectoryInfo(crfModelDir).Parent.FullName, "CRFLocalizedMapping.txt");

            if (File.Exists(crfModelNameMappingFile))
            {
                string message = "";
                SdCheckoutFile(crfModelNameMappingFile, out message);
                Console.WriteLine(message);

                // edit the mapping file
                EditCRFModelMappingFile(crfModelNameMappingFile, Path.GetFileName(crfFilePath), true);
            }
            else
            {
                throw new FileNotFoundException(crfModelNameMappingFile + " not found.");
            }

            string tempCRFBinFile;

            if (!CompileCRF(crfModelDir, _localConfig.Lang, out tempCRFBinFile))
            {
                throw new Exception("Compile crf file failed for " + crfFilePath);
            }

            Microsoft.Tts.Offline.Compiler.LanguageData.LanguageDataHelper.ReplaceBinaryFile(
                generatedFilePath,
                tempCRFBinFile,
                Microsoft.Tts.Offline.Compiler.LanguageData.ModuleDataName.PolyphonyModel);

            // delete the temp file
            File.Delete(tempCRFBinFile);

            return File.Exists(generatedFilePath);
        }

        /// <summary>
        /// CRF compiler
        /// </summary>
        /// <param name="localArgs">crf model folder</param>
        /// <param name="errorSet">error set</param>
        /// <remarks>success or not</remarks>
        private static bool CompileCRF(string crfModelDir, Language lang, out string crfBinFile)
        {
            try
            {
                using (MemoryStream outputStream = new MemoryStream())
                {
                    Collection<string> addedFileNames = new Collection<string>();
                    Microsoft.Tts.Offline.Compiler.CrfModelCompiler.Compile(crfModelDir, outputStream, addedFileNames, lang);
                    crfBinFile = Helper.GetTempFileName();

                    using (FileStream fs = new FileStream(crfBinFile, FileMode.OpenOrCreate))
                    {
                        using (BinaryWriter bw = new BinaryWriter(fs))
                        {
                            bw.Write(outputStream.ToArray());
                        }
                    }
                    return File.Exists(crfBinFile);
                }
            }
            catch
            {
                crfBinFile = null;
                return false;
            }
        }

        /// <summary>
        /// Load CRF model name mapping(model name and localized name).
        /// </summary>
        /// <example>
        /// The mapping txt file is like this:
        /// 
        /// Map between polyphony model:
        /// 差	->	cha.crf	Being_used
        /// 长	->	chang.crf	Being_used
        /// 当	->	dang.crf	Being_used
        /// 行	->	hang.crf	Being_used
        /// 系	->	xi.crf	Unused
        /// </example>
        /// <param name="mappingFile">Mapping File Path.</param>
        /// <param name="crfFileName">Error set.</param>
        /// <param name="isUse">is true, using "Being_used", else "Unused" in mapping file</param>
        /// <returns>CRF name mapping set</returns>
        public void EditCRFModelMappingFile(string mappingFile, string crfFileName, bool isUse)
        {
            // start flag of crf model mapping data
            const string MappingFlag = "Map between polyphony model:";

            // line number start index is 1, next line will be read is 2
            int lineNumber = 2;
            bool needModify = true;
            bool charExist = false;
            // check the char whether to be used
            string usingInfo = isUse ? "Being_used" : "Unused";

            using (StreamReader reader = new StreamReader(mappingFile))
            {
                // if the first line is correct, read the file to end.
                if (string.Compare(MappingFlag, reader.ReadLine()) == 0)
                {
                    while (!reader.EndOfStream)
                    {
                        string[] mapping = reader.ReadLine().Split('\t');

                        string currentChar = mapping[0];
                        string currentCRFFile = mapping[2];
                        string currentUsingInfo = mapping[3];


                        // if current line's char is same with charName para, check whether need to modify this line
                        if (string.Equals(currentChar, _localConfig.CurrentTrainingChar.CharName))
                        {
                            // if crf file name and using info are same, don't modify
                            // else edit thie line
                            if (string.Compare(currentCRFFile, crfFileName) == 0 &&
                                string.Compare(currentUsingInfo, usingInfo) == 0)
                            {
                                needModify = false;
                                break;
                            }
                            else
                            {
                                charExist = true;
                                break;
                            }
                        }
                        ++lineNumber;
                    }
                }
                else
                {
                    return;
                }
            }

            if (needModify)
            {
                string content = string.Format("{0}\t->\t{1}\t{2}", _localConfig.CurrentTrainingChar, crfFileName, usingInfo);
                Util.EditLineInFile(mappingFile, lineNumber, content, !charExist);
            }
        }

        /// <summary>
        /// Use FrontendMeasure to test testcaseFile and results saved to outputPath
        /// FrontendMeasure.exe -mode runtest -log "[path]\log.txt" -x "[path]\test.xml"
        /// </summary>
        /// <param name="logPath">fm result file</param>
        public bool TestCRFModel(string srcDatFile, string testcaseFile, string logPath, ref string message)
        {
            string sdMsg = string.Empty;

            try
            {
                // copy generaetd data file to offline\LocaleHandler folder
                string datDestPath = Path.Combine(_localConfig.OfflineToolPath, "LocaleHandler", Path.GetFileName(srcDatFile));
                File.Copy(srcDatFile, datDestPath, true);
                Console.WriteLine("copy " + srcDatFile + " to " + datDestPath);

                Console.WriteLine("FrontendMeasure.exe" + string.Format("-mode runtest -x {0} -log {1}", testcaseFile, logPath));

                Int32 sdExitCode = CommandLine.RunCommandWithOutputAndError(FrontendMeasurePath,
                        string.Format("-mode runtest -x {0} -log {1}", testcaseFile, logPath), null, ref sdMsg);

                if (sdExitCode == 0 && !string.IsNullOrEmpty(sdMsg))
                {
                    message = string.Format("Successfully run test: {0}", logPath);
                    return true;
                }
                else
                {
                    message = string.Format("Failed run test : {0}", sdMsg);
                    return false;
                }
            }
            catch (Exception e)
            {
                message = string.Format("--{0}. Failed to training : {1}", e.Message, logPath);
            }

            return false;
        }

        /// <summary>
        /// Generate script item from raw text(only generate to word level).
        /// </summary>
        /// <param name="text">Plain text.</param>
        /// <returns>ScriptItem.</returns>
        public ScriptItem GenerateScriptItem(string text)
        {
            if (string.IsNullOrEmpty(text))
            {
                throw new ArgumentNullException("text");
            }

            ScriptItem item = new ScriptItem();
            item.Text = text;

            foreach (SP.TtsUtterance utt in _wordBreaker.EspUtterances(text))
            {
                using (utt)
                {
                    if (utt.Words.Count == 0)
                    {
                        continue;
                    }

                    ScriptSentence sentence = new ScriptSentence();
                    foreach (SP.TtsWord word in utt.Words)
                    {
                        if (!string.IsNullOrEmpty(word.WordText))
                        {
                            ScriptWord scriptWord = new ScriptWord();
                            scriptWord.Grapheme = word.WordText;

                            if (!string.IsNullOrEmpty(word.Pronunciation))
                            {
                                scriptWord.Pronunciation = word.Pronunciation.ToLowerInvariant();
                            }

                            scriptWord.WordType = WordType.Normal;
                            if (word.WordType == SP.TtsWordType.WT_PUNCTUATION)
                            {
                                scriptWord.WordType = WordType.Punctuation;
                            }

                            scriptWord.PronSource = (TtsPronSource)word.PronSource;

                            sentence.Words.Add(scriptWord);
                        }
                    }

                    sentence.Text = sentence.BuildTextFromWords();
                    item.Sentences.Add(sentence);
                }
            }

            return item;
        }

        #region Sentence Separate
        /// <summary>
        /// Sentence Separate files in folder
        /// </summary>
        /// <example>
        /// input:
        /// 07073游戏网	8090《魔兽部落》刀塔战场杀四方	在8090魔兽部落中，战争并非是一场儿戏，而是真真切切的强者对决!在刀塔战场上，这是堡垒的争夺赛，更是一场尊严的较量!而此时，策略就显得尤为重要，队员们如何分配战力?在同一战场又怎样配合?在这即将来临的风暴前，只有努力提升自身实力，才能幸存下来! 8090魔兽部落：http://msbl.8090yxs.com/?xw-msbl 8090魔兽部落刀塔战场玩法每天20:00开启，持续25分钟，进入副本后随即分配到两个敌对阵营，最先达到5000阵营积分或结束时阵营积分高的阵营将获得胜利。在20:10和20:15，战场内刷新BOSS，击杀BOSS有概率掉落武器碎片、再生宝石、强化石等。 战况瞬息万变，击杀敌方卫兵可增加1点阵营积分，卫兵每30S刷新一波。击杀对方阵营玩家可增加2点阵营积分，同时记录击杀排行，副本结束后根据击杀排行榜给予个人奖励。获胜方阵营可获得：荣誉1000点+经验50W+金币15W。失败方阵营可获得：荣誉500点+经验30W+金币10W。 击杀排行也是有丰厚奖励的!第一名：荣誉4000点+勋章碎片*2+中级强化石*5+强化石*10。第二名：荣誉2000点+勋章碎片*1+中级强化石*3+强化石*5。第三名：荣誉1500点+勋章碎片*1+中级强化石*2+强化石*3。第四—十名：荣誉1000点+中级强化石*1+强化石*2。第11—999名：荣誉1000点+强化石*1。与个人PK不同,个人战主要体现为玩家的个人能力，而这项战斗主要表现为玩家与玩家之间的配合! 8090魔兽部落采用经典游戏模式MMORPG，融合当下最新技术，完美展现即时战斗特点，技能炫酷，内容丰富，各种特色玩法，等待玩家的发现，期待玩家的探索。3个职业个人生涯贯穿着整个游戏故事。绚丽的冒险故事，打开玩家风尘已久的记忆之门，重新去探索那一段经典的岁月，欢迎体验神秘之旅，尽在8090魔兽部落。 37《轩辕剑之天之痕》此次有幸请到素有古典美女之称的刘诗诗作代言,游戏中的拓跋玉儿…
        /// 
        /// output:
        /// 07073游戏网	8090《魔兽部落》刀塔战场杀四方	在8090魔兽部落中，战争并非是一场儿戏，而是真真切切的强者对决!
        /// 在刀塔战场上，这是堡垒的争夺赛，更是一场尊严的较量!
        /// 而此时，策略就显得尤为重要，队员们如何分配战力?在同一战场又怎样配合?在这即将来临的风暴前，只有努力提升自身实力，才能幸存下来!
        /// 8090魔兽部落：http://msbl.8090yxs.com/?xw-msbl 8090魔兽部落刀塔战场玩法每天20:00开启，持续25分钟，进入副本后随即分配到两个敌对阵营，最先达到5000阵营积分或结束时阵营积分高的阵营将获得胜利。
        /// 在20:10和20:15，战场内刷新BOSS，击杀BOSS有概率掉落武器碎片、再生宝石、强化石等。
        /// 战况瞬息万变，击杀敌方卫兵可增加1点阵营积分，卫兵每30S刷新一波。
        /// </example>
        /// <param name="paragraph">input content</param>
        /// <returns>sentence break results</returns>
        public void DoSentenceSeparate(string inputDir, string outputDir, string searchPattern = "*.txt")
        {
            foreach (string file in Directory.GetFiles(inputDir, searchPattern))
            {
                using (StreamReader reader = new StreamReader(file))
                {
                    while (reader.Peek() > -1)
                    {
                        string paragraph = reader.ReadLine();
                        if (string.IsNullOrEmpty(paragraph))
                        {
                            continue;
                        }

                        List<string> outputs = new List<string>();
                        int startIndex = 0;

                        while (startIndex < paragraph.Length)
                        {
                            int endIndex = FindEndIndex(paragraph, startIndex, SentenceSpliters);
                            if (endIndex != -1)
                            {
                                outputs.Add(paragraph.Substring(startIndex, endIndex - startIndex));
                                startIndex = endIndex;
                            }
                            else
                            {
                                break;
                            }
                        }

                        if (startIndex < paragraph.Length)
                        {
                            outputs.Add(paragraph.Substring(startIndex, paragraph.Length - startIndex));
                        }

                        File.WriteAllLines(Path.Combine(outputDir, Path.GetFileName(file)), outputs);
                    }
                }
            }
        }

        /// <summary>
        /// Genereate word break result for each file
        /// </summary>
        /// <param name="wildcard">input file path, like "D:\corpus\*.txt"</param>
        /// <param name="outputDir">output folder</param>
        public void DoWordBreakFiles(string wildcard, string outputDir)
        {
            string[] inFilePaths = Util.GetAllFiles(wildcard);
            if(inFilePaths.Length == 0)
            {
                return; 
            }
            
            Task[] tasks;
            if (inFilePaths.Length <= _localConfig.MaxThreadCount)
            {
                tasks = new Task[inFilePaths.Length];
            }
            else
            {
                tasks = new Task[_localConfig.MaxThreadCount];
            }

            Util.ConsoleOutTextColor("Start word breaking");

            for (int i = 0; i < tasks.Length; i++)
            {
                string[] filesToProcess = inFilePaths.Where((input, index) => (index % tasks.Length == i)).ToArray();

                // start each task nad show process info when this task complete
                tasks[i] = Task.Factory.StartNew(() =>
                        {
                            WordBreakFiles(filesToProcess, outputDir);
                        }
                    ).ContinueWith((ancient) =>
                        {
                            //Console.WriteLine(string.Format("Processed {0} files, total {1} files", ProcessedFileCount, inFilePaths.Length));
                        }
                    );
            }

            Task.WaitAll(tasks);
        }

        /// <summary>
        /// Word break each file
        /// </summary>
        /// <param name="fileProcessed">files to be processed</param>
        /// <param name="outputDir">output folder</param>
        private void WordBreakFiles(string[] fileProcessed, string outputDir)
        {
            WordBreaker breaker = new WordBreaker(_localConfig.Lang, _localConfig.VoicePath, _localConfig.LangDataPath);

            foreach (string filePath in fileProcessed)
            {
                string fileName = Path.GetFileName(filePath);

                // if the filtered file already exist, skip this file
                string outputFilePath = Path.Combine(outputDir, fileName);
                if (File.Exists(outputFilePath))
                {
                    ++ProcessedFileCount;
                    Console.WriteLine("File " + fileName + " exist, skipped!");
                    continue;
                }

                Console.WriteLine("Breaking file " + fileName);

                int counter = 0;
                using (StreamReader reader = new StreamReader(filePath))
                {
                    while (reader.Peek() > -1)
                    {
                        string sentence = reader.ReadLine().Trim().Replace(" ", "").Replace("\t", "");

                        if (string.IsNullOrEmpty(sentence))
                        {
                            continue;
                        }

                        try
                        {
                            File.AppendAllText(outputFilePath, string.Join(" ", breaker.BreakToWords(sentence)));
                            File.AppendAllText(outputFilePath, Environment.NewLine);
                            ++counter;
                        }
                        catch
                        {
                            continue;
                        }

                        if (counter >= _localConfig.ShowTipCount &&
                            counter % _localConfig.ShowTipCount == 0)
                        {
                            Console.WriteLine(string.Format("Searching {0} in {1}", counter, fileName));
                        }
                    }
                }

                ++ProcessedFileCount;
            }

            breaker.Dispose();
        }

        /// <summary>
        /// Find the first spliter index
        /// </summary>
        private static int FindEndIndex(string paragraph, int startIndex, string[] splitters)
        {
            int splitterLength = 0;
            int minEndIndex = paragraph.Length;
            foreach (var splitter in splitters)
            {
                int endIndex = paragraph.IndexOf(splitter, startIndex);
                if (endIndex != -1 && endIndex < minEndIndex)
                {
                    minEndIndex = endIndex;
                    splitterLength = splitter.Length;
                }
            }
            if (minEndIndex == paragraph.Length)
            {
                return -1;
            }
            else
            {
                return minEndIndex + splitterLength;
            }
        }

        #endregion

        /// <summary>
        /// Call sd.exe edit file
        /// </summary>
        /// <param name="filePath">file path</param>
        /// <param name="message">result</param>
        public void SdCheckoutFile(string filePath, out string message)
        {
            string sdMsg = string.Empty;

            try
            {
                Int32 sdExitCode = CommandLine.RunCommandWithOutputAndError(SdToolPath,
                                                string.Format("edit {0}", filePath),
                                                Path.GetDirectoryName(SdToolPath),
                                                ref sdMsg);

                if (sdExitCode == 0)
                {
                    message = string.Format("Checked out file: {0}", filePath);
                }
                else
                {
                    message = string.Format("Failed to check out file: {0}.\r\n{1}", filePath, sdExitCode, sdMsg);
                }
            }
            catch (Exception e)
            {
                message = string.Format("{0}. Failed to check out file: {1}", e.Message, filePath);
            }
        }

        /// <summary>
        /// Call sd.exe revert file
        /// </summary>
        /// <param name="filePath">file path</param>
        /// <param name="message">result</param>
        public void SdRevertUnchangedFile(string filePath, out string message)
        {
            string sdMsg = string.Empty;

            try
            {
                Int32 sdExitCode = CommandLine.RunCommandWithOutputAndError(SdToolPath,
                                                string.Format("revert {0}", filePath),
                                                Path.GetDirectoryName(SdToolPath),
                                                ref sdMsg);

                if (sdExitCode == 0 && !string.IsNullOrEmpty(sdMsg))
                {
                    message = string.Format("Reverted unchanged file: {0}", filePath, sdMsg);
                }
                else
                {
                    message = string.Empty;
                }
            }
            catch (Exception e)
            {
                message = string.Format("--{0}. Failed to revert unchanged file: {1}", e.Message, filePath);
            }
        }

        /// <summary>
        /// Verify excel sheet, make sure it contains at least 2 rows, 2 columns
        /// first row it the title line, 2 columns one for case, one for pron
        /// </summary>
        /// <param name="xlSheet">excel sheet</param>
        private bool VerifyExcelSheet(Excel.Worksheet xlSheet)
        {
            Excel.Range range = xlSheet.UsedRange;
            // at least 2 rows, 2 columns
            if (range.Rows.Count <= 1 || range.Columns.Count <= 1)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Properly clean up Excel interop objects
        /// </summary>
        /// <param name="obj">excel object</param>
        private static void ReleaseExcelObject(object obj)
        {
            try
            {
                System.Runtime.InteropServices.Marshal.ReleaseComObject(obj);
                obj = null;
            }
            catch
            {
                obj = null;
            }
            finally
            {
                GC.Collect();
            }
        }

        #endregion
    }
}
